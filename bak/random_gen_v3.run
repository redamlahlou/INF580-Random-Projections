## random Instance generator

param version := 3; # version of the random generator
param outputFile_root := "Inst_"; # prefix for the name of all the Instances
param min_val := -100; # minimum random value for c,A and b
param max_val := 100;  # maximum random value for c,A and b

param dim_I default 1; # This parameter represents card(I)
param dim_J default 1; # This parameter represents card(J)=card(I) in version 1

## auxiliary variables to generate random instances of dimension...
# ...dim_min + (d-1)*dim_step for d in {1,...,dim_num}
param dim_min := 2;
param dim_step := 2;
param dim_num := 5;
param dim_max := dim_min + (dim_num-1)*dim_step;
set dims := dim_min..dim_max by 2;

param N_Inst := 1; # number of instances per dimension

param c_rand{1..dim_max};
param A_rand{1..dim_max,1..dim_max};
param b_rand{1..dim_max};
param x_rand{1..dim_max};
param k_;
param k_max := round(log(dim_max),0);
param T_{1..k_max,1..dim_max};

model inverse.mod; # model that will allow us to calculate the generalized inverse of A on the fly


### generating the random Instances ###
for{dim in dims}{
	for{instance in 1..N_Inst}{
		let dim_I := dim;
		let dim_J := dim_I; # version 1
		
		## generating T for the projection 
		
		let k_ := round(log(dim_J),0); # lower dimension;
		for{i in 1..k_}{
			for{j in 1..dim_I}{
				let T_[i,j] := Normal(0,1/sqrt(k_));
			}
		}
		
		## generating x to get b so that we have a feasible instance
		
		for{j in 1..dim_J}{
			let x_rand[j] := Uniform(0,1)*max_val;
		}
		
		## creating the files and adding the number of rows and columns (for P et TP) and k (for TP)
		
		printf "## Instance generated by random_gen.run, version %i\n\n", version > ("Inst_" & dim & "_" & instance & ".dat");
		printf "## Instance generated by random_gen.run, version %i\n\n", version > ("Inst_proj_" & dim & "_" & instance & ".dat");
		
		printf "param n := %i;\n",dim_I >> ("Inst_" & dim & "_" & instance & ".dat");
		printf "param m := %i;\n\n",dim_J >> ("Inst_" & dim & "_" & instance & ".dat");
		
		printf "param n := %i;\n",k_ >> ("Inst_proj_" & dim & "_" & instance & ".dat");
		printf "param m := %i;\n",dim_J >> ("Inst_proj_" & dim & "_" & instance & ".dat");
		printf "param k := %i;\n\n",k_ >> ("Inst_proj_" & dim & "_" & instance & ".dat");
		
		## generating c;
		
		printf "param c :=\n" >> ("Inst_" & dim & "_" & instance & ".dat");
		printf "param c :=\n" >> ("Inst_proj_" & dim & "_" & instance & ".dat");
		for{j in 1..dim_J}{
			let c_rand[j] := min_val + Uniform(0,1)*(max_val - min_val);
			printf "%i\t%.3f\n", j, c_rand[j]  >> ("Inst_" & dim & "_" & instance & ".dat");
			printf "%i\t%.3f\n", j, c_rand[j]  >> ("Inst_proj_" & dim & "_" & instance & ".dat");
		}
		printf ";\n\n"  >> ("Inst_" & dim & "_" & instance & ".dat");
		printf ";\n\n"  >> ("Inst_proj_" & dim & "_" & instance & ".dat");
		
		## generating A(for P and TP), his projection (for TP);
		
		printf "param A :=\n" >> ("Inst_"  & dim & "_" & instance & ".dat");
		printf "param A :=\n" >> ("Inst_proj_"  & dim & "_" & instance & ".dat");
		
		for{i in 1..dim_I}{
			for{j in 1..dim_J}{
				let A_rand[i,j] := min_val + Uniform(0,1)*(max_val - min_val);
				printf "%i\t%i\t%.3f\n", i, j, A_rand[i,j]  >> ("Inst_"  & dim & "_" & instance & ".dat");
			}
		}
		
		for{i in 1..k_}{
			for{j in 1..dim_J}{
				printf "%i\t%i\t%.3f\n", i, j, sum{l in 1..dim_I} T_[i,l]*A_rand[l,j] >> ("Inst_proj_"  & dim & "_" & instance & ".dat");
			}
		}
		
		printf ";\n\n"  >> ("Inst_" & dim & "_" & instance & ".dat");
		printf ";\n\n"  >> ("Inst_proj_" & dim & "_" & instance & ".dat");
		
		
		## generating b : drawing x randomly and taking b = A*x (we'll forget x) -> feasible Instance.
		
		printf "param b :=\n" >> ("Inst_" & dim & "_" & instance & ".dat");
		printf "param b :=\n" >> ("Inst_proj_" & dim & "_" & instance & ".dat");
		
		for{i in 1..dim_I}{
			let b_rand[i] := sum{j in 1..dim_J} A_rand[i,j]*x_rand[j];
			printf "%i\t%.3f\n", i, b_rand[i]  >> ("Inst_" & dim & "_" & instance & ".dat");
		}
		
		for{i in 1..k_}{
			printf "%i\t%.3f\n", i, sum{l in 1..dim_I} T_[i,l]*b_rand[l]  >> ("Inst_proj_" & dim & "_" & instance & ".dat");
		}
		
		printf ";\n\n"  >> ("Inst_" & dim & "_" & instance & ".dat");
		printf ";\n\n"  >> ("Inst_proj_" & dim & "_" & instance & ".dat");
		
		
		## adding T to the projected data
		
		printf "param T :=\n" >> ("Inst_proj_"  & dim & "_" & instance & ".dat");
		
		for{i in 1..k_}{
			for{j in 1..dim_I}{
				printf "%i\t%i\t%.3f\n", i, j, T_[i,j]  >> ("Inst_proj_"  & dim & "_" & instance & ".dat");
			}
		}
		
		printf ";\n\n"  >> ("Inst_proj_" & dim & "_" & instance & ".dat");
		
		## adding the generalized inverse of A to the original and projected data
		# calculating G as an LP
		
		reset data;
		data ("Inst_proj_" & dim & "_" & instance & ".dat");
		
		
		option solver cplex;
		option solver_msg 0;  # hidding the solver messages
		
		solve;
		
		# adding G to the original data
		
		printf "param G := \n" >> ("Inst_" & dim & "_" & instance & ".dat");
		for{j_ in 1..card(J)}{
			for{i_ in 1..card(I)}{
				printf "%i\t%i\t%.3f\n", j_, i_, G[j_,i_]  >> ("Inst_" & dim & "_" & instance & ".dat");
			}
		}
		
		printf ";\n\n"  >> ("Inst_" & dim & "_" & instance & ".dat");
		
		
		# adding G to the projected data
		
		printf "param G := \n" >> ("Inst_proj_" & dim & "_" & instance & ".dat");
		for{j_ in 1..card(J)}{
			for{i_ in 1..card(I)}{
				printf "%i\t%i\t%.3f\n", j_, i_, G[j_,i_]  >> ("Inst_proj_" & dim & "_" & instance & ".dat");
			}
		}
		
		printf ";\n\n"  >> ("Inst_proj_" & dim & "_" & instance & ".dat");
	}
}

