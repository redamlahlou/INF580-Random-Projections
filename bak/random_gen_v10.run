## random Instance generator

param version := 10; # version of the random generator
param outputFile_root := "Inst_"; # prefix for the name of all the Instances
param min_val := -500; # minimum random value for c,A and b
param max_val := 500;  # maximum random value for c,A and b

param dim_I default 1; # This parameter represents card(I)
param dim_J default 1; # This parameter represents card(J)=card(I) in version 1

## auxiliary variables to generate random instances of dimensions...
# ...(n,m,k)=(m/ratio,m,m/ratio*fraction), m in dims, ratio in ratios, fraction in fractions

#set dims := {10,30,90,270,810};        # modulo 3
set dims := {810,270,90,30,10};
param max_dim := max{dim in dims} dim;
set ratios := {1.0,0.8,0.6};  # ratios n/m
param min_ratio := min{ratio in ratios} ratio;
set fractions := 0.25 .. 0.05 by -0.5;
param max_fraction := max{fraction in fractions} fraction;

param N_Inst := 5; # number of instances per dimension

param c_rand{1..max_dim};
param A_rand{1..max_dim/min_ratio,1..max_dim};
param b_rand{1..max_dim/min_ratio};
param x_rand{1..max_dim};
param k_;
#param k_max := round(log(max_dim)/log(sqrt(2)),0);
param k_max := round(max_dim/min_ratio*max_fraction,0);
param T_{1..k_max,1..max_dim/min_ratio};

model inverse.mod; # model that will allow us to calculate the generalized inverse of A on the fly


### generating the random Instances ###
#for{fraction in {0.25}}{
#for{ratio in {1}}{
#	for{dim in {10}}{
#		for{instance in {1}}{

for{fraction in fractions}{
for{ratio in ratios}{
	for{dim in dims}{
		for{instance in 1..N_Inst}{
			let dim_J := dim; #
			let dim_I := round(dim/ratio,0);
			
			
			## generating T for the projection 
			
			#let k_ := round(log(dim_I)/log(sqrt(2)),0); # lower dimension;
			let k_ := round(dim_I*fraction,0);
			for{i in 1..k_}{
				for{j in 1..dim_I}{
					let T_[i,j] := Normal(0,1/sqrt(k_));
				}
			}
			
			## generating x to get b so that we have a feasible instance
			
			for{j in 1..dim_J}{
				let x_rand[j] := Uniform(0,1)*max_val;
			}
			
			## creating the files and adding the number of rows and columns (for P et TP) and k (for TP)
			
			printf "## Instance generated by random_gen.run, version %i\n\n", version > ("Inst_" & dim_I & "_" & dim_J & "_" & k_ & "_" & instance & ".dat");
			printf "## Instance generated by random_gen.run, version %i\n\n", version > ("Inst_proj_" & dim_I & "_" & dim_J & "_" & k_ & "_" & instance & ".dat");
			
			printf "param n := %i;\n",dim_I >> ("Inst_" & dim_I & "_" & dim_J & "_" & k_ & "_" & instance & ".dat");
			printf "param m := %i;\n\n",dim_J >> ("Inst_" & dim_I & "_" & dim_J & "_" & k_ & "_" & instance & ".dat");
			
			#printf "param n_proj := %i;\n",k_ >> ("Inst_proj_" & dim_I & "_" & dim_J & "_" & k_ & "_" & instance & ".dat");
			#printf "param m_proj := %i;\n",dim_J >> ("Inst_proj_" & dim_I & "_" & dim_J & "_" & k_ & "_" & instance & ".dat");
			printf "param k := %i;\n\n",k_ >> ("Inst_proj_" & dim_I & "_" & dim_J & "_" & k_ & "_" & instance & ".dat");
			
			## generating c;
			
			printf "param c :=\n" >> ("Inst_" & dim_I & "_" & dim_J & "_" & k_ & "_" & instance & ".dat");
			#printf "let c_proj :=\n" >> ("Inst_proj_" & dim_I & "_" & dim_J & "_" & k_ & "_" & instance & ".dat");
			for{j in 1..dim_J}{
				let c_rand[j] := min_val + Uniform(0,1)*(max_val - min_val);
				printf "%i\t%.3f\n", j, c_rand[j]  >> ("Inst_" & dim_I & "_" & dim_J & "_" & k_ & "_" & instance & ".dat");
				#printf "%i\t%.3f\n", j, c_rand[j]  >> ("Inst_proj_" & dim_I & "_" & dim_J & "_" & k_ & "_" & instance & ".dat");
			}
			printf ";\n\n"  >> ("Inst_" & dim_I & "_" & dim_J & "_" & k_ & "_" & instance & ".dat");
			#printf ";\n\n"  >> ("Inst_proj_" & dim_I & "_" & dim_J & "_" & k_ & "_" & instance & ".dat");
			
			## generating A(for P and TP), his projection (for TP);
			
			printf "param A :=\n" >> ("Inst_"  & dim_I & "_" & dim_J & "_" & k_ & "_" & instance & ".dat");
			printf "param A_proj :=\n" >> ("Inst_proj_"  & dim_I & "_" & dim_J & "_" & k_ & "_" & instance & ".dat");
			
			for{i in 1..dim_I}{
				for{j in 1..dim_J}{
					let A_rand[i,j] := min_val + Uniform(0,1)*(max_val - min_val);
					printf "%i\t%i\t%.3f\n", i, j, A_rand[i,j]  >> ("Inst_"  & dim_I & "_" & dim_J & "_" & k_ & "_" & instance & ".dat");
				}
			}
			
			for{i in 1..k_}{
				for{j in 1..dim_J}{
					printf "%i\t%i\t%.3f\n", i, j, sum{l in 1..dim_I} T_[i,l]*A_rand[l,j] >> ("Inst_proj_"  & dim_I & "_" & dim_J & "_" & k_ & "_" & instance & ".dat");
				}
			}
			
			printf ";\n\n"  >> ("Inst_" & dim_I & "_" & dim_J & "_" & k_ & "_" & instance & ".dat");
			printf ";\n\n"  >> ("Inst_proj_" & dim_I & "_" & dim_J & "_" & k_ & "_" & instance & ".dat");
			
			
			## generating b : drawing x randomly and taking b = A*x (we'll forget x) -> feasible Instance.
			
			#printf "#param x_rand :=\n#" >> ("Inst_proj_" & dim_I & "_" & dim_J & "_" & k_ & "_" & instance & ".dat");
			#display x_rand >> ("Inst_proj_" & dim_I & "_" & dim_J & "_" & k_ & "_" & instance & ".dat");
			#printf "\n\n#" >> ("Inst_proj_" & dim_I & "_" & dim_J & "_" & k_ & "_" & instance & ".dat");
			
			printf "param b :=\n" >> ("Inst_" & dim_I & "_" & dim_J & "_" & k_ & "_" & instance & ".dat");
			printf "param b_proj :=\n" >> ("Inst_proj_" & dim_I & "_" & dim_J & "_" & k_ & "_" & instance & ".dat");
			
			

			for{i in 1..dim_I}{
				let b_rand[i] := sum{j in 1..dim_J} A_rand[i,j]*x_rand[j];
				printf "%i\t%.3f\n", i, b_rand[i]  >> ("Inst_" & dim_I & "_" & dim_J & "_" & k_ & "_" & instance & ".dat");
			}
			
			#display A_rand,x_rand,b_rand;
			
			for{i in 1..k_}{
				printf "%i\t%.3f\n", i, sum{l in 1..dim_I} T_[i,l]*b_rand[l]  >> ("Inst_proj_" & dim_I & "_" & dim_J & "_" & k_ & "_" & instance & ".dat");
			}
			
			printf ";\n\n"  >> ("Inst_" & dim_I & "_" & dim_J & "_" & k_ & "_" & instance & ".dat");
			printf ";\n\n"  >> ("Inst_proj_" & dim_I & "_" & dim_J & "_" & k_ & "_" & instance & ".dat");
			
			
			## adding T to the projected data
			
			printf "param T :=\n" >> ("Inst_proj_"  & dim_I & "_" & dim_J & "_" & k_ & "_" & instance & ".dat");
			
			for{i in 1..k_}{
				for{j in 1..dim_I}{
					printf "%i\t%i\t%.3f\n", i, j, T_[i,j]  >> ("Inst_proj_"  & dim_I & "_" & dim_J & "_" & k_ & "_" & instance & ".dat");
				}
			}
			
			printf ";\n\n"  >> ("Inst_proj_" & dim_I & "_" & dim_J & "_" & k_ & "_" & instance & ".dat");
			
		}
	}
}
}


