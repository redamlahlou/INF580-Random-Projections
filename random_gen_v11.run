## random Instance generator

param version := 11; # version of the random generator
param outputFile_root := "Inst_"; # prefix for the name of all the Instances
param min_val := -100; # minimum random value for c,A and b
param max_val := 100;  # maximum random value for c,A and b

param dim_I default 1; # This parameter represents card(I)
param dim_J default 1; # This parameter represents card(J)>card(I)

## auxiliary variables to generate random instances of dimensions...
# ...(n,m,k)=(m/ratio,m,m/ratio*fraction), m in dims, ratio in ratios, fraction in fractions

#set dims := {10,30,90,270,810};        # modulo 3
#set dims := {300,600,900,1200,1500,1800,2100,2500,2800,3200};
set dims := {1500};
param max_dim := max{dim in dims} dim;
#set ratios := {0.9,0.8,0.7};  # ratios n/m
set ratios := {0.7};  # ratios n/m
param min_ratio := min{ratio in ratios} ratio;
#set fractions := {1/5,1/4,1/3,1/2};  # ratios k/n
set fractions := {1/5,1/4,1/3,1/2};  # ratios k/n
param max_fraction := max{fraction in fractions} fraction;

param N_inst := 5; # number of instances per dimension
param N_proj := 10; # number of projections over the same instance

param c_rand{1..max_dim};
param A_rand{1..max_dim/min_ratio,1..max_dim};
param b_rand{1..max_dim/min_ratio};
param x_rand{1..max_dim};
param k_;
param k_max := round(max_dim/min_ratio*max_fraction,0);
param T_{1..k_max,1..max_dim/min_ratio};

for{dim in dims}{
	let dim_J := dim; 							# number of columns of A
	
	for{ratio in ratios}{
		let dim_I := round(dim*ratio,0);     	# number of rows of A
	
		for{fraction in fractions}{
			let k_ := round(dim_I*fraction,0);	# number of rows of T
			
			for{instance in 1..N_inst}{
				display dim_J,dim_I,k_;
				printf "\nInstance: %i/%i\n",instance,N_inst;
				
				## generating x_rand to get b so that we have a feasible instance
					
				for{j in 1..dim_J}{
					let x_rand[j] := Uniform(0,1)*max_val;
				}
				
				## generating c
					
				for{j in 1..dim_J}{
					let c_rand[j] := round(Uniform(0,1)*max_val);;
				}
				
				## generating A
					
				for{i in 1..dim_I}{
					for{j in 1..dim_J}{
						let A_rand[i,j] := min_val + Uniform(0,1)*(max_val - min_val);
					}
				}
				
				## generating b=A*x
				
				for{i in 1..dim_I}{
					let b_rand[i] := sum{j in 1..dim_J} A_rand[i,j]*x_rand[j];
				}
				
				### writing n,m,c,A and b on a .dat file for each instance ###
				
				printf "## Instance generated by random_gen.run, version %i\n\n", version > ("Inst_" & dim_I & "_" & dim_J & "_" & k_ & "_" & instance & ".dat");
				printf "param n := %i;\n",dim_I >> ("Inst_" & dim_I & "_" & dim_J & "_" & k_ & "_" & instance & ".dat");
				printf "param m := %i;\n\n",dim_J >> ("Inst_" & dim_I & "_" & dim_J & "_" & k_ & "_" & instance & ".dat");
				
				## adding c
				printf "param c :=\n" >> ("Inst_" & dim_I & "_" & dim_J & "_" & k_ & "_" & instance & ".dat");
				for{j in 1..dim_J}{
					printf "%i\t%.3f\n", j, c_rand[j]  >> ("Inst_" & dim_I & "_" & dim_J & "_" & k_ & "_" & instance & ".dat");
				}
				printf ";\n\n"  >> ("Inst_" & dim_I & "_" & dim_J & "_" & k_ & "_" & instance & ".dat");
				
				## adding A
				
				printf "param A :=\n" >> ("Inst_"  & dim_I & "_" & dim_J & "_" & k_ & "_" & instance & ".dat");
				for{i in 1..dim_I}{
					for{j in 1..dim_J}{
						printf "%i\t%i\t%.3f\n", i, j, A_rand[i,j]  >> ("Inst_"  & dim_I & "_" & dim_J & "_" & k_ & "_" & instance & ".dat");
					}
				}
				printf ";\n\n"  >> ("Inst_" & dim_I & "_" & dim_J & "_" & k_ & "_" & instance & ".dat");
				
				## adding b
				
				printf "param b :=\n" >> ("Inst_" & dim_I & "_" & dim_J & "_" & k_ & "_" & instance & ".dat");
				for{i in 1..dim_I}{
					printf "%i\t%.3f\n", i, b_rand[i]  >> ("Inst_" & dim_I & "_" & dim_J & "_" & k_ & "_" & instance & ".dat");
				}		
				printf ";\n\n"  >> ("Inst_" & dim_I & "_" & dim_J & "_" & k_ & "_" & instance & ".dat");
					
					
				for{projection in 1..N_proj}{
					
					printf "Projection: %i/%i\n",projection,N_proj;
					
					## generating T (projection matrix) for each projection (n,m,k and instance are fixed)
					
					for{i in 1..k_}{
						for{j in 1..dim_I}{
							let T_[i,j] := Normal(0,1/sqrt(k_));
						}
					}
					
					
					### writing k,A_proj,b_proj and T in a .dat for each projection (for TP) ###
					
					printf "## Instance generated by random_gen.run, version %i\n\n", version > ("Inst_proj_" & dim_I & "_" & dim_J & "_" & k_ & "_" & instance & "_" & projection & ".dat");
					printf "param k := %i;\n\n",k_ >> ("Inst_proj_" & dim_I & "_" & dim_J & "_" & k_ & "_" & instance & "_" & projection & ".dat");

					
					## adding A_proj
					
					printf "param A_proj :=\n" >> ("Inst_proj_" & dim_I & "_" & dim_J & "_" & k_ & "_" & instance & "_" & projection & ".dat");
					for{i in 1..k_}{
						for{j in 1..dim_J}{
							printf "%i\t%i\t%.3f\n", i, j, sum{l in 1..dim_I} T_[i,l]*A_rand[l,j] >> ("Inst_proj_" & dim_I & "_" & dim_J & "_" & k_ & "_" & instance & "_" & projection & ".dat");
						}
					}				
					printf ";\n\n"  >> ("Inst_proj_" & dim_I & "_" & dim_J & "_" & k_ & "_" & instance & "_" & projection & ".dat");
					
					
					## adding b_proj = T*b=T(A*x)=A_proj*x
					
					printf "param b_proj :=\n" >> ("Inst_proj_" & dim_I & "_" & dim_J & "_" & k_ & "_" & instance & "_" & projection & ".dat");
					for{i in 1..k_}{
						printf "%i\t%.3f\n", i, sum{l in 1..dim_I} T_[i,l]*b_rand[l]  >> ("Inst_proj_" & dim_I & "_" & dim_J & "_" & k_ & "_" & instance & "_" & projection & ".dat");
					}
					printf ";\n\n"  >> ("Inst_proj_" & dim_I & "_" & dim_J & "_" & k_ & "_" & instance & "_" & projection & ".dat");
					
					
					## adding T to the projected data
					
					printf "param T :=\n" >> ("Inst_proj_" & dim_I & "_" & dim_J & "_" & k_ & "_" & instance & "_" & projection & ".dat");
					for{i in 1..k_}{
						for{j in 1..dim_I}{
							printf "%i\t%i\t%.3f\n", i, j, T_[i,j]  >> ("Inst_proj_" & dim_I & "_" & dim_J & "_" & k_ & "_" & instance & "_" & projection & ".dat");
						}
					}
					printf ";\n\n"  >> ("Inst_proj_" & dim_I & "_" & dim_J & "_" & k_ & "_" & instance & "_" & projection & ".dat");
					
				}
			}
		}
	}
}


